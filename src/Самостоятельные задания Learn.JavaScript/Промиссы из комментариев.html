<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    Это работает просто потому, что resolve выступает в качестве ссылки на ту функцию, 
    которую мы напишем внутри then. Работает это не только с промисами, 
    а вообще в самом языке. Пример:

    function outer(a, b, callback) {
      const res = a + b
      callback(res)
    }
    
    function inner(value) {
      console.log(`Получил значение ${value}`)
    }
    
    outer(5, 5, inner)

    В параметрах outer содержится два числовых значения и функция. 
    Я передаю в outer функцию inner и вызываю ее тогда, 
    когда мне это будет нужно. Внутри outer я обозначил функцию inner как callback.
    
    С промисами абсолютно точно также - 
    resolve является ссылкой на ту функцию, которую мы прописываем в then. 
    А это значит что мы можем просто передать название функции внутрь then
    
    вроде как все просто должно быть))
    
    UPD:
    
    То есть вызов resolve(a), например, это вызов той самой функции,
     которую мы передали в then. 
     В данном случае просто не использовали обертку в виде стрелочной функции))
    
    
    Да, когда в метод .then передается функция (или переменная содержащая код функции), 
    то .then сам вызывает ее с result в качестве аргумента, после выполнения промиса. 
    Первая переданная функция вызывается в случае если промис выполнился успешно, 
    вторая - если нет.  
</body>
</html>